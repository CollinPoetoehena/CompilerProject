start phase RootPhase {
    // TODO: Comment unfinished actions because they might cause an error!
    actions {
        pass SPdoScanParse;
        // Then perform ContextAnalysis to create and link the Ste's
        ContextAnalysis;
        // Then convert variable initializations into regular assignments, after ContextAnalysis
        RegularAssignments;
        // Then perform TypeChecking
        // TypeChecking;
        // // Then compile boolean disjunction and conjunction by introducing the TernaryOp node
        // CompilingBooleanDisjunctionAndConjunction;
        // // then compile boolean cast (type and result type) expressions with the TernaryOp node
        // CompilingBooleanCastExpressions;
        // Then print the output of the compiler
        print;
    }
};

/*
SHORT MEMORY TUTORIAL IN COCONUT AND C:

Use CCNcopy when you update something in the AST that you are not returning, otherwise it is lost 
or can cause a double free error because a global variable in a traversal.c file will be freed by CoCoNut
after that traversal, and then anything can still point to this already freed global variable and cause an error.
In short:
    - changes to the node of a traversal function of that node are saved because this 
        node is returned at the end, so no CCNcopy required.
    - changes to the AST outside this node, such as the VarDecl nodes changed in renameforidentifiers.c traversal
        require a CCNcopy because otherwise the result is lost and can cause a memory leak or a double free, etcetera!
    - one thing to keep in mind is that you still need to copy some things, such as STRcopy for setting the
        FOR_START_EXRP(node) = ASTvar(FOR_VAR(node));
        because otherwise you would still have a memory issue because now FOR_START_EXRP(node) and
        FOR_VAR(node) point to the same char * in memory! So, it should look like this ASTvar(STRcpy(FOR_VAR(node)))

PRO TIP (from experience :)):
    Try to make changes to the AST in the traversal functions of that node, try to avoid changing a node outside of 
    its traversal function as much as possible because it can lead to unpredictable behaviour otherwise! Unless
    it is absolutely unavoidable you can try doing it, but be careful and test everything thorougly again then!
*/

//TODO: remove when done, these are common commands:
// make
// ./civicc ../test/basic/check_success/binops.cvc
// yacc -Wcounterexamples parser.y
// This is how you can print a memory address: printf("variable A is at address: %p\n", (void*)&FUNDEF_NAME(initFunDefNode));

//**********************************************************************************************************************************************
// TODO: implement the last milestones :) -> milestone 12 and 13 and test them very thorougly 
//and make them perfect! I have untill the end of the period because milestone 14 and 15 can be skipped,
// so focus on milestone 12 and 13 untill the end then i also have time for Programmeeratlen studying 
//for the exam and some less stress, etc :)!!!


// TODO: typechecking, ask Simon:
// the file contains this:     //fun() + bar();
// but this should give an error right???
// and the result 4 should be 5 right???


// TODO: how to generate the file for assembly in the traversal, is there code about that somewhere???? Ask Simon


// ************************************************************************************************************************************

traversal Print {
    uid = PRT
};


// ******************************************************************************************************************************************

// TODO: convert it to have the good scoping for:
// ./civicc ../test/contextAnalysisTest/updateGlobalScopesCheck/checkUpdatingGlobalScopes.cvc 
// ./civicc ../test/basic/functional/var_init.cvc 
// This needs to be done by this:
/*
RegularAssignments traversal needs to be after ContextAnalysis.

Then update the linking traversal in the ContextAnalysis phase:
remove it and see if you can do the linking in the same traversal of the Var Ste's or the
Fun Ste's, so Var and VarLet in SteVar and FunCall in SteFun creation traversals!
Then test everything again!

When making the VarLet and Var in RegularAssignments traversal, these need to be updated with the SteLink 
of the already existing links, so use them and add them manually!

Then if that works, remove the old solution of the extra traversal!

Then uncomment the other actions in the start phase and test everything thorougly again!
*/


// ******************************************************************************************************************************************

// The ContextAnalysis phase is mainly used to create Symbol tables
phase ContextAnalysis {
    actions {
        /*
        This traversal systematicly rename all the identifiers in for loops and save it to the node.
        This is very handy in the creation of symbol tables because you can then just
        create symbol table entries for the identifiers in for loops without special operations.
        */
        traversal RenameForIdentifiers {
            uid = RFI,
            // Also rename all the occurrences of the for variable
            nodes = { FunBody, VarDecl, Stmts, For, FunCall, Assign, Var, VarLet },
            travdata {
                // Hash tables are used to handle converting nested for loops
                user htable_ptr for_identifiers_table,
                user htable_ptr for_assignNodes_table
            }
        };

        // Create Variable Symboltables, linking will be done in a separate traversal
        traversal CreateVariableSymbolTableEntries {
            uid = CVS,
            nodes = { 
                // Program to link first symbol table entries of var and fun
                Program,
                // FunDef to use for the linking to the first SteVar 
                FunDef,
                // FunBody to traverse the VarDecls and Stmts
                FunBody, 
                // These nodes are used to create new Symbol Table entries
                // For node has already been converted, so nothing that needs to be done here now!
                GlobDecl, GlobDef, VarDecl, Param,
                // These nodes are used to update their link once they occur in a program
                Var, Varlet,
                // This node is just used to traverse the args child expression to find potential Var, VarLet links
                FunCall

            }
        };
        
        // Create Function Symboltables, linking will be done in a separate traversal
        traversal CreateFunctionSymbolTableEntries {
            uid = CFS,
            nodes = {
                // Program to link first symbol table entries of var and fun
                Program,
                // FunDef to use for creating a new SteFun 
                FunDef,
                // Param node (= LinkedList) to link the params of a FunDef
                Param
            }
        };

        /*
        This traversal function links FunCall nodes to their SteFun link.
        This is separated because the order of function definitions does not matter in Civic
        as explained in the CiviC manual on top of page 7.
        */
        traversal LinkFunCallsToSteFunNode {
            uid = LFTSF,
            nodes = {
                // Program to link first symbol table entries of var and fun
                Program,
                // The FunCall node is used to update its link once it occurs in a program
                FunCall
            }
        };

        // // This traversal links all the Var, VarLet and FunCall occurrences to the correct Ste
        // traversal LinkSymbolTableEntries {
        //     uid = LSTE,
        //     nodes = { 
        //         // Program to save the global chain of SteVar and SteFun and going to the right traversal functions
        //         Program,
        //         // FunDef and FunBody to use for saving the current chain and going to the right traversal functions
        //         FunDef,
        //         // VarDecl is used to determine what scope to use for a variable with the same name as the VarDecl
        //         VarDecl,
                // // These nodes are used to update their link once they occur in a program
                // Var, Varlet, FunCall
        //     }
        // };

        // /*
        // This traversal is used to fix the scoping of the RegularAssignment traversal for Assign 
        // nodes. The scoping of Assign nodes is not correctly done in the above traversal because we
        // chose to do the RegularAssignment traversal before ContextAnalysis, these benefits outweigh the
        // drawbacks of having it after ContextAnalysis, however, to fix the scoping that is not 
        // correctly done because of that this traversal is needed to fix that.
        // */
        // traversal UpdateGlobalVardeclScopes {
        //     uid = UGVS,
        //     nodes = { 
        //         // Program to save the global chain of SteVar and SteFun and going to the right traversal functions
        //         Program,
        //         // Assign node is used to update the scope to global of the Var in the Assign node
        //         // if it needs to be updated
        //         Assign,
        //         // Var node is used to check and update the ste link if necssary
        //         Var
        //     },
        //     travdata {
        //         // A hash table is used to save the Var occurrences in to see if the scope of 
        //         // the ste link has to be updated
        //         user htable_ptr assign_var_occurred
        //     }
        // };
    }
};

// This traversal should transform Variable Initialisations into Regular Assignments. Should be 
// performed before the ContextAnalysis because that phase can create Ste's for the transformed code
traversal RegularAssignments {
    uid = RA,
    nodes = { Program, Decls, GlobDef, FunBody, VarDecl}
};

// The TypeChecking phase is used to check all the types
phase TypeChecking {
    actions {
        // This traversal is used for type checking, such as matching assignments and funcall types
        traversal TypeMatchingAssignmentsFunCalls {
            uid = TMAF,
            nodes = {
                /*
                        These nodes are used for checking the types
                */
                // Foreach function definition
                FunDef,
                // Traverse into the function body
                FunBody,
                // Case assignment: Infer expression type. Compare with variable type
                Assign,
                // Case if-then-else: Infer type of predicate expression: Boolean? 
                // Traverse into then-branch. Traverse into else-branch
                IfElse,
                // Case while-/do-loop: Infer type of predicate expression: Boolean? Traverse into loop body
                While, DoWhile,
                // Case for-loop: Infer types of bound/step expressions: Integer? Traverse into loop body
                For,
                // Case return: check with fundef return type
                Return,
                // Then continue with next statement...
                /*
                        These nodes are used to infer the types of the Expression
                */
                // Case FunCall: Foreach argument expression: Infer argument type
                // Compare with corresponding parameter type. Yield function return type
                FunCall, Exprs,
                Cast,
                // Case BinOp: Infer left operand type. Infer right operand type. Yield operator result type
                BinOp,
                // Case MonOp: Infer operand type. Yield operator result type
                Monop,
                Var,
                // Case IntConstant: Yield int
                Num,
                // Case FloatConstant: Yield float
                Float,
                // Case BoolConstant: Yield bool
                Bool
            },
            travdata {
                // Hash tables are used to handle type checking nested funcalls
                // This hash table is used to save the funcall index to get the last funcall node
                user htable_ptr funcalls_funcallIndex_node,
                // This hash table is used to save the funcall index to get the last parmam index of that funcall
                user htable_ptr funcalls_funcallIndex_paramIndex
            }
        };
    }
};

/*
This traversal extends the intermediate representation of the compiler by conditional
expressions as exemplified by the C ternary operator pred ?then :else and to systematically
transform all Boolean operations in question into semantically equivalent conditional expressions.
*/
traversal CompilingBooleanDisjunctionAndConjunction {
    uid = CBDC,
    nodes = { BinOp }
};

/*
This traversal should transform cast expressions with Boolean argument or result value
into semantically equivalent non-cast expressions (milestone 10).
This is done after the CBDC traversal because the binops need to be traversed already for this
traversal because a Cast can have a BinOp Expr child as well.
*/
traversal CompilingBooleanCastExpressions {
    uid = CBCE,
    // It traverses all Cast expressions that have a boolean result or bool cast type
    nodes = { Cast, BinOp, FunCall, Bool }
};

// TODO later: Create separate traversal to convert for loop to while loop, easier after ContextAnalysis, but when to do it????
// this is done before code generation because it has no for loops in the VM for example, like this:
// int declaration eruit, dan de for omzetten naar een while loop en de body extenden met de increment aan het eind 
// (step expr from for loop)
// maakt niet uit waar, zolang het voor de assembly genereren is, gaat alleen over for naar while omzetten de rest kan hetzelfde
//TODO: create
//     // This traversal converts For nodes to While nodes
//     traversal ConvertForToWhile {
//         uid = CFTW,
//         nodes = { For }
//     };

/*
TODO: 
    milestone 15 is helemaal optioneel en om de bonus punten te krijgen moet je heel veel optimalisatie
    doen om een beetje punten te krijgen, dus die niet doen!
    milestone 14 is een beetje optioneel, probeer die alleen te doen als je nog veel tijd over hebt
    na milestones 12 en 13, 12 en 13 moet je echt sowieso goed krijgen!
    
    ***************************************************************************************************************************
    TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
    DUS HET PLAN NU: 
    MILESTONE 12 EN 13 MAKEN EN ZORG DAT DIE HELEMAAL GOED ZIJN EN PERFECT MET ALLE TESTS, SCHRIJF HIER OOK EXTRA TESTS VOOR ZELF!
    FOCUS GEWOON DAAROP NU EN MILESTONE 14 EN 15 MOET JE GEWOON OVERSLAAN, DIE ZIJN TOCH OPTIONEEL EIGENLIJK!
    DUS:
    MILESTONE 12 EN 13 MAKEN TOT HET EIND
    MILESTONE 14 EN 15 OVERSLAAN EN NIET DOEN WANT DAT IS DE TIJD NIET WAARD, ZORG DAT MILESTONE 12 EN 13 GEWOON PERFECT STAAN EN HEEL
    GOED GETEST ZIJN! 14 EN 15 KRIJG JE AMPER TOT GEEN PUNTEN VOOR EN JE MOET ER HEEL VEEL VOOR DOEN, DUS SLA DIE NU OVER!
    DUS MIILESTONE 12 EN 13 MAKEN EN DAN ALLES HEEEEEEL GOED TESTEN DE KOMENDE 2 WEKEN EN DAN VOOR DE REST FOCUSSEN OP PROGRAMMEERTALEN
    LEREN VOOR HET TENTAMEN! DAN KOMT HET HELEMAAL GOED EN HEBBEN WE GEWOON ROND DE 7 VOOR HET COMPILER PROJECT EN DAT IS AL HEEL 
    GOED, MET EEN VOLDOENDE IS HET AL HEEL GOED, KOMT GOED, DUS NU MILESTONE 12 EN 13 AFMAKEN :)!
    ***************************************************************************************************************************

    milestone 12 en 13 zijn super belangrijk, die moeten heel goed staan, test alles goed met de test suite
    EN je eigen test files of die kloppen, test dit heel goed en grondig, dit moet goed zijn!

    Uitleg milestones 12 en 13 voor assembly genereren:
    assembly uitprinten, ipv code printen ga je assembly code printen naar de output file die meegegeven is
    main.c: regel 66:
            global.output_file = optarg;
    Standaard C om de file aan te maken, maak de file aan, de assembly code is een tekst bestand dat je gaat aanmaken
    milestone 12 en 13 zijn in 1 traversal die je uitbreidt op 1 file die je aanmaakt
    gebruik de reference compiler om een voorbeeld te zien van assembly dat gegenereert wordt:
    Zo kan je de reference compiler gebruiken: 
    chmod +x ./civcc -> geeft permission voor alles
    gebruik uit de /bin folder de reference compiler: civcc
    run die compiler dan vervolgens op een .cvc file
    hoeft niet 1 op 1 overeen te komen met jou compiler, zolang de output maar gelijk is.

    Algemene tips:
    functies zijn voornamelijk moeilijk, ruimte op de stack maken voor variabele
    begin met de statements, dat is goed te doen, ga gewoon de milestones af.
    Het is in principe minder tijd rovend dan de symbol tables, dat was het meeste tijd
    Je kan een klein beetje kijken naar de print.c, sommige dingen zijn redelijk straight forward
    zoals een BinOp is bijvoorbeeld in principe 2 dingen traversen en dan addition doen.
*/
// This traversal is used for assembly code generation
// traversal AssemblyCodeGeneration {
//     uid = ACG,

// };

/*
TODO: this is done during CodeGeneration, but when and how, etc???
    Explanation about Strict logic disjunction and conjunction:
        Strict logic disjunction and conjunction are logical operations that implement the logical OR 
        and AND operations on Boolean operands. However, in the case of strict logic disjunction and 
        conjunction, the operators are defined as arithmetic operators for addition and multiplication, respectively, 
        and not as logical operators. This means that they operate on Boolean values as if they were integers, 
        with the value true being treated as 1 and the value false being treated as 0.

        In strict logic disjunction, the result is true if either or both operands are true, and false otherwise. 
        It is implemented by the addition operator (+).

        In strict logic conjunction, the result is true only if both operands are true, and false otherwise. 
        It is implemented by the multiplication operator (*).
*/

enum Type {
    // T_ collides with bison/flex generated stuff.
    prefix = CT,
    values {
        int, float, bool, void
    }
};

enum MonOpEnum {
    prefix = MO,
    values {
        // logical negation (!, MO_not), used for boolean values (true, false)
        // unary minus (-, MO_neg), arithmetic negation, used for arithmetic values (=numbers, etc)
        not, neg
    }
};

enum BinOpEnum {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

nodeset Constants = {Float, Bool, Num};

nodeset Operations = {Binop, Monop, TernaryOp};

nodeset Decl = {GlobDef, GlobDecl, FunDef};

nodeset Vars = {VarDecl, Var, VarLet};

nodeset Expr = {Cast, FunCall, Var, ArrExpr} | (Constants | Operations);

nodeset Stmt = {Assign, ExprStmt, IfElse, While, DoWhile, For, Return};

// Link is used for the Symbol table to link a node (Var, VarLet or FunCall) to the symbol table
nodeset Link = {SteVar, SteFun};

root node Program {
    children {
        Decls decls { constructor, mandatory }
    },

    attributes {
        // Contains first global symbol occuring (can be used for linking)
        // No need for constructor because it is set only later on in ContextAnalysis
        SteVar first_ste_variables,
        SteFun first_ste_functions
    }
};

node Decls {
    children {
        Decl decl { constructor },
        Decls next { constructor }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

// This is for the array expression, which is extension 2 and 3
node ArrExpr {
    children {
        Exprs exprs { constructor, mandatory }
    }
};

// Ids are only used for array extensions (= arr[m,n] m and n are Ids), so not yet used
node Ids {
    children {
        Ids next   
    },
    attributes {
        string name
    }
};

node ExprStmt {
    children {
        Expr expr { constructor, mandatory }
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

// (= later on, same as Var and VarLet, such as void foo(){}; return foo();, foo in return is the FunCall)
node FunCall {
    children {
        Exprs args { constructor }
    },
    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Cast {
    children {
        Expr expr {constructor, mandatory }
    }, 
    attributes {
        Type type {constructor }
    }
};

// Used for first extension: nested functions
node FunDefs {
    children {
        FunDef fundef { constructor, mandatory },
        FunDefs next
    }
};

/*
This ast uses the FunDef node for both the function definition and the function declaration.
A function declaration is simply represented as a FunDef node without a FunBody.
FunHeader not necessary because it has no added value for the ast, first param could be FunHeader.
*/
node FunDef {
    children {
        FunBody body { constructor },
        Param params { constructor }
    },
    attributes {
        Type type { constructor },
        string name { constructor, mandatory },
        bool export { constructor },
        // Link to its own symbol table
        SteFun symbol_table,
        // Link to first symbol table of this functions scope
        SteVar first_ste_variables
        // No need to do anything with EXTERN for the FunDec because they are always external!
    }
};

// local_fundefs is used for nested function definitions
node FunBody {
    children {
        VarDecl decls { constructor },
        // local_fundefs is for the first extension, ignore for now
        FunDefs local_fundefs,
        Stmts stmts { constructor }
    }
};

node IfElse {
    children {
        Expr cond { constructor, mandatory },
        Stmts then { constructor },
        Stmts else_block { constructor }
    }
};

node While {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node DoWhile {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node For {
    children {
        Expr start_expr { constructor, mandatory },
        Expr stop { constructor, mandatory },
        Expr step { constructor },
        Stmts block { constructor }
    },

    attributes {
        string var { constructor }
    }
};

node GlobDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims
    },

    attributes {
        Type type { constructor },
        string name { constructor }
    }
};

node GlobDef {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor }
    },

    attributes {
        Type type { constructor },
        string name { constructor },
        bool export { constructor },
        // Link to its own symbol table, can be used in RegularAssignments traversal for example
        SteVar symbol_table
    }
};

node Param {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims { constructor },
        Param next { constructor }
    },

    attributes {
        string name { constructor, mandatory },
        Type type { constructor }
    }
};

node VarDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor },
        VarDecl next { constructor }
    },

    attributes {
        string name { constructor },
        Type type { constructor },
        // Link to its own symbol table, can be used in RegularAssignments traversal for example
        SteVar symbol_table
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    }, 

    attributes {
        BinOpEnum op { constructor },
        // Save the infered operator type in typechecking in the node to use in code generation later
        Type operator_type_signature
    }
};

node Monop {
    children {
        Expr operand { constructor, mandatory }
    },

    attributes {
        MonOpEnum op { constructor },
        // Save the infered operator type in typechecking in the node to use in code generation later
        Type operator_type_signature
    }
};

// This node is used for the format: pred?then:else
node TernaryOp {
    children {
        Expr predicate { constructor, mandatory },
        Expr then_expr { constructor, mandatory },
        Expr else_expr { constructor, mandatory }
    },
    attributes {
        // Save the inferred type of the ternary operator expression to use in code generation later
        // Can be copied from the BinOp turned into TernaryOp
        Type type_signature { constructor }
    }
};

// Variable in assignment (= later on, such as int a = 5; a = 7, a is the VarLet).
node VarLet {
    children {
        // Indices is used for extensions, so leave it for now
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

// Variable in an expression (= later on, such as int d = a * 5, a is the Var).
node Var {
    children {
        // NOT used currently, indices is for the array extensions
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};


// This is the node for a Symbol table chain for variables
node SteVar {
    children {
        // Parent points to a higher nesting level
        SteVar parent { constructor },
        // LinkedList data structure for next symbol table
        SteVar next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor }
    }
};

// This is the node for a Symbol table chain for functions. Every function definition gets its own symbol table.
node SteFun {
    children {
        // Parent wijst naar hogere nesting level
        SteFun parent { constructor },
        // LinkedList data structure for next symbol table
        SteFun next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor },
        // Params is the LinkedList from the FunDef, should contain the first value of 
        // the FunDef params. From the first value the LinkedList chain can be followed.
        Param params { constructor }
    }
};
