start phase RootPhase {
    // Comment unfinished actions because they might cause an error!
    actions {
        pass SPdoScanParse;
        ContextAnalysis;
        // TODO: uncomment when that is done, otherwise it might cause an error!
        // RegularAssignments;
        print;
    }
}; 

//TODO: remove when done, these are common commands:
// make
// ./civicc ../test/basic/check_success/binops.cvc
// yacc -Wcounterexamples parser.y

// ************************************************************************************************************************************
// TODO:
// milestone 6 is only first part , other parts are for extensions, so not necessary
// For loop i's can have the same id at the start, but rename them in a previous traversal
// milestones 8 and 11 are only for extensions!

// milestone 9:
// || wordt lazy geevalueerd
// voor bool operators een apart iets, dus || &&. Maak daar een ternary node voor
// Dus eig die dingen omvormen in ternary statements
// Example:
// funcCallA() || funcallb()
// Als funCallA() true returned dan zou funcallb() niet uitgevoerd hoeven worden (als die side effects heeft is dat slecht)
// Traversal hoeft dan alleen over de binops te gaan en dan de logicoperators van Binop

// milestone 10:
// in assembly worden booleans anders afgehandeld
// Er zijn geen assembly instructions om van en naar booleans te casten
// Dit moet je dus zelf gaan doen met de cijfers
// cast van int naar bool moet dan bijv een > 0 vergelijking, etc en andersom
// traversal gaat over de Cast nodes

traversal Print {
    uid = PRT
};

// TODO later: Create separate traversal to convert for loop to while loop, easier after CA??

// TODO: convert to new solution explained by TA
phase ContextAnalysis {
    actions {
        // This traversal systematicly rename all the identifiers in for loops and save it to the node.
        // This is very handy in the creation of symbol tables because you can then just
        // create symbol table entries for the identifiers in for loops without special operations.
        traversal RenameForIdentifiers {
            uid = RFI,
            // Also rename all the occurrences of the for variable
            nodes = { For, FunCall, Assign, Var, VarLet }
        };

        traversal CreateVariableSymbolTableEntries {
            // Create Variable Symboltables
            uid = CVS,
            nodes = { 
                // Program to link first symbol table entries of var and fun
                Program,
                // FunDef to use for the linking to the first SteVar 
                // TODO: do this with (first travFunbody, then after that link using global node_st *symboltable)
                FunDef,
                // FunBody to traverse the VarDecls and Stmts
                FunBody, 
                // These nodes are used to create new Symbol Table entries
                GlobDecl, GlobDef, VarDecl, Param, For,
                // These nodes are used to update their link once they occur in a program
                Var, Varlet
            }
        };
        
        // TODO: uncomment when variables symbol tables are working and make this one!
        // traversal CreateFunctionSymbolTableEntries {
        //     // Create Function Symboltables
        //     uid = CFS,
        //     nodes = {
        //         // Program to link first symbol table entries of var and fun
        //         Program,
        //         // FunDef to use for creating a new SteFun 
        //         // TODO: do this with (first travFunbody, then after that link using global node_st *symboltable)
        //         FunDef,
        //         // Param node (= LinkedList) to link the params of a FunDef
        //         Param,
        //         // These nodes are used to update their link once they occur in a program
        //         FunCall
        //     }
        // };
    }
};

// traversal ContextAnalysis {
//     uid = CA,
//     // TODO: you cannot declare a variable inside a Statement, so only linking can occur there
//     nodes = {
//             // Program, FunBody and IfElse, While, DoWhile, to go to the appropriate nodes' traversal functions
//             // Decls and Stmts to link the children. These nodes are above the others so will be traversed first
//             Program, Decls, Stmts, FunBody, IfElse, While, DoWhile, For, 
//             // VarDecl, GlobDecl, GlobDef, FunDef and Param to create a new Ste
//             VarDecl, GlobDecl, GlobDef, FunDef, Param,
//             // Exprs and Assign to go to the Var and Varlet nodes traversal functions
//             Exprs, Assign,
//             // Var, Varlet and FunCall to link a symbol table entry with it's name
            // Var, Varlet, FunCall
//         }
// };

traversal RegularAssignments {
    // This traversal should transform Variable Initialisations into Regular Assignments
    uid = RA,
    // TODO: what is milestone 6, only first 2 paragraphs right, the rest is for arrays???? Ask Simon!
    nodes = {FunBody, VarDecl, GlobDef, For}
    // FunBody is used to first traverse the VarDecls and then the Stmts and append the 
    // saved initializations to the stmts, these are filled after TRAVdecls(node) of FunBody
    // For loop has something special to it, the above nodes are the correct nodes
};

// TODO: for type checking see slides Semantic analysis for implementation hint on type checking!
// Explanation on type checking: 

enum SymbolTableType {
    // Can have two types, variable or function
    prefix = STT,
    values {
        // TODO: is this correct, what about Param???
        var, varlet, function
    }
};

enum Type {
    // T_ collides with bison/flex generated stuff.
    prefix = CT,
    values {
        int, float, bool, void
    }
};

enum MonOpEnum {
    prefix = MO,
    values {
        not, neg
    }
};

enum BinOpEnum {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

nodeset Constants = {Float, Bool, Num};

nodeset Operations = {Binop, Monop};

nodeset Decl = {GlobDef, GlobDecl, FunDef};

nodeset Vars = {VarDecl, Var, VarLet};

nodeset Expr = {Cast, FunCall, Var, ArrExpr} | (Constants | Operations);

nodeset Stmt = {Assign, ExprStmt, IfElse, While, DoWhile, For, Return};

// Link is used for the Symbol table to link a node to the symbol table
nodeset Link = {SteVar, SteFun};
// Link is voor na de symbol table om de symbol table entry te linken met de node (Var, Varlet, Funcall)

root node Program {
    children {
        Decls decls { constructor, mandatory }
    },

    attributes {
        // Contains first global symbol occuring (can be used for linking)
        // No need for constructor because it is set only later on in ContextAnalysis
        SteVar first_ste_variables,
        SteFun first_ste_functions
    }
};

node Decls {
    children {
        Decl decl { constructor, mandatory },
        Decls next { constructor }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

// This is for the array expression, which is extension 2 and 3
node ArrExpr {
    children {
        Exprs exprs { constructor, mandatory }
    }
};

// Ids are only used for array extensions (= arr[m,n] m and n are Ids), so not yet used
node Ids {
    children {
        Ids next   
    },
    attributes {
        string name
    }
};

node ExprStmt {
    children {
        Expr expr { constructor, mandatory }
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

// (= later on, same as Var and VarLet, such as void foo(){}; return foo();, foo in return is the FunCall)
node FunCall {
    children {
        Exprs args { constructor }
    },
    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Cast {
    children {
        Expr expr {constructor, mandatory }
    }, 
    attributes {
        Type type {constructor }
    }
};

// Used for first extension: nested functions
node FunDefs {
    children {
        FunDef fundef { constructor, mandatory },
        FunDefs next
    }
};

// This ast uses the FunDef node for both the function definition and the function declaration. 
// A function declaration is simply represented as a FunDef node without a FunBody.
// FunHeader not necessary because it has no added value for the ast, first param could be FunHeader.
node FunDef {
    children {
        FunBody body { constructor },
        Param params { constructor }
    },
    attributes {
        Type type { constructor },
        string name { constructor, mandatory },
        bool export { constructor },
        // Link to its own symbol table
        SteFun symbol_table,
        // Link to first symbol table of this functions scope
        SteVar first_ste_variables
        // No need to do anything with EXTERN for the FunDec because they are always external!
    }
};

// local_fundefs is used for nested function definitions
node FunBody {
    children {
        VarDecl decls { constructor },
        // local_fundefs is for the first extension, ignore for now
        FunDefs local_fundefs,
        Stmts stmts { constructor }
    }
};

node IfElse {
    children {
        Expr cond { constructor, mandatory },
        Stmts then { constructor },
        Stmts else_block { constructor }
    }
};

node While {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node DoWhile {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node For {
    children {
        Expr start_expr { constructor, mandatory },
        Expr stop { constructor, mandatory },
        Expr step { constructor },
        Stmts block { constructor }
    },

    attributes {
        string var { constructor }
    }
};

node GlobDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims
    },

    attributes {
        Type type { constructor },
        string name { constructor }
    }
};

node GlobDef {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor }
    },

    attributes {
        Type type { constructor },
        string name { constructor },
        bool export { constructor }
    }
};

node Param {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims { constructor },
        Param next { constructor }
    },

    attributes {
        string name { constructor, mandatory },
        Type type { constructor }
    }
};

node VarDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor },
        VarDecl next { constructor }
    },

    attributes {
        string name { constructor },
        Type type { constructor }
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    }, 

    attributes {
        BinOpEnum op { constructor }
    }
};

node Monop {
    children {
        Expr operand { constructor, mandatory }
    },

    attributes {
        MonOpEnum op { constructor }
    }
};

// Variable in assignment (= later on, such as int a = 5; a = 7, a is the VarLet).
node VarLet {
    children {
        // Indices is used for extensions, so leave it for now
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

// Variable in an expression (= later on, such as int d = a * 5, a is the Var).
node Var {
    children {
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};


//TODO: convert nodes, reuse as much as possible from the old contextanalysis traversal
// Also see the picture from the lesson (also send to Sandro, can be found there)
node SteVar {
    children {
        // Parent wijst naar hogere nesting level
        SteVar parent { constructor },
        // LinkedList data structure for next symbol table
        SteVar next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor }
        //SymbolTableType symbol_type { constructor } //TODO: probably not necessary anymore
    }
};

// Every function gets its own symbol table
node SteFun {
    children {
        // Parent wijst naar hogere nesting level
        SteFun parent { constructor },
        // LinkedList data structure for next symbol table
        SteFun next { constructor }
    }, 

    // TODO: functions have their own scope, so one func that has 'a' and another that has 'a' should not give an error!
    // Check this in the isSymbolUnique function, so change that up a bit, maybe with parent you can check it!
    // TODO: also, fundef foo(){int foo;} -> is a valid program in CiviC
    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor },
        // Params is the LinkedList from the FunDef, should contain the first value of 
        // the FunDef params. From the first value the LinkedList chain can be followed.
        Param params { constructor }
        //SymbolTableType symbol_type { constructor }, //TODO: probably not necessary anymore
    }
};

// Symbol table entry
// node Ste {
//     // variablen en functies
//     children {
//         // LinkedList data structure for next symbol table
//         Ste next { constructor },
//         // TODO: een lijst per functie en 1 global
//         // Parent wijst naar hogere nesting level
//         Ste parent

//         // FunDef
//         // Traverse funbody
//         // travdata can be used for Ste

//         // Start with Ste's for the variables only
//         // Separate traversal for fundefs
//         // 2 losse tables, 1 voor vars, 1 voor functinos, allebei linkedlist
//         // 2 nodes, SteVar, SteFun
//     }, 

//     attributes {
//         string name { constructor },
//         Type type { constructor },
//         int nesting_level { constructor },
//         SymbolTableType symbol_type { constructor },
//         // Params is the LinkedList from the FunDef, should contain the first value of 
//         // the FunDef params. From the first value the LinkedList chain can be followed.
//         Param params { constructor }
//     }
// };
// Milestone 5 symbol table
// Each symbol table entry would feature the name of the variable as a character string, 
// its type as well as its nesting level (starting with zero for the global context)

// basic heeft 2 scopes, global en in een funcall
// LinkedList is dan het handigst, alle functies hebben zijn eigen symbol table
// Alles die de AST ombouwt is een traversal
// Dus Context analysis (Symbol table bouwen) en TypeChecking zijn traversals

// TODO: milestone 6
// This needs to be a separate traversal as well
// int a = expr;
// milestone 6 is loskoppelen van die expr van een VarDecl, je knipt hem dus van de boom after
// en weer aan de boom, dit is handig uiteindelijk voor code generation
