start phase EntryPoint {
    info = "Denotes the entry point of your compiler",
    
    actions {
        pass SPdoScanParse;
        Print;
    }
};

traversal Print {
    uid = PRT
};

/*** AST ***/
enum monop_type {
    prefix = MO,
    values {
        not, neg
    }
};

enum binop_type {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

enum basic_type {
    prefix = BT,
    values {
        bool, int, float
    }
};

enum return_type {
    prefix = RT,
    values {
        void, basic_type
    }
};

nodeset Expr = {Num, Float, Bool, Binop, Var};
nodeset Stmt = {Assign, IfStatement, WhileStatement, DoWhileStatement, ForStatement, ReturnStatement};
nodeset Declaration = {FunDec, FunDef, GlobalDec, GlobalDef};

// Nodes you want to be able to link to from your symbol table.
// nodeset Link = Expr | Stmt;

root node Program {
    children {
        Declarations declarations { constructor, mandatory }
    }
};

node Declarations {
    // Zero or more Declarations, same implementation as Stmts node
    children {
        Declaration declaration { constructor, mandatory }, 
        Declarations next { constructor }
    }
};

node FunDec {
    children {
        FunHeader funHeader { constructor, mandatory }
    }
};

node FunDef {
    children {
        FunHeader funHeader { constructor, mandatory },
        FunBody funBody { constructor, mandatory }
    }
};

node GlobalDec {
    attributes {
        basic_type id { constructor }
    }
};

node GlobalDef {
    children {
        Assign assignment { constructor, mandatory }
    },

    attributes {
        basic_type id { constructor }
    }
};

node FunHeader {
    children {
        Params params { constructor }
    },

    attributes {
        return_type id { constructor }
    }
};

node FunBody {
    children {
        VarDec varDec { constructor },
        Stmts statements { constructor }
    }
};

node Params {
    // Zero or more Params, same implementation as Stmts
    children {
        Param param { constructor, mandatory },
        Params next { constructor }
    }, 
};

node Param {
    attributes {
        basic_type id { constructor }
    }
};

node VarDec {
    children {
        Assign assignment { constructor }
    },

    attributes {
        basic_type id { constructor }
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node IfStatement {
    children {
        Expr expr { constructor, mandatory },
        Block block { constructor, mandatory },
        Block else_block { constructor }
    }
};

node WhileStatement {
    children {
        Expr expr { constructor, mandatory },
        Block block { constructor, mandatory }
    }
};

node DoWhileStatement {
    children {
        Block block { constructor, mandatory },
        Expr expr { constructor, mandatory }
    }
};

node ForStatement {
    children {
        Assign assignment { constructor, mandatory },
        Expr expr { constructor, mandatory },
        Expr optional_expr { constructor },
        Block block { constructor, mandatory }
    }
};

node ReturnStatement {
    children {
        Expr optional_expr { constructor }
    }
};

node Block {
    children {
        Stmts stmts { constructor }
    }
};

node Binop {
    children {
        Expr left  { constructor, mandatory },
        Expr right { constructor, mandatory }
    },
    
    attributes {
        binop_type type { constructor }
    }
};

// Variable in assignment.
node VarLet {
    attributes {
        string name { constructor }
    }
};

// Variable in an expression.
node Var {
    attributes {
        string name { constructor }    
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};

/* Symbol table entry
 * TODO: fill in.
node Ste {

}
*/


