start phase RootPhase {
    // Comment unfinished actions because they might cause an error!
    actions {
        pass SPdoScanParse;
        // TODO: uncomment when done with testing RA traversal, otherwise it might cause an error or bug!
        ContextAnalysis;
        //RegularAssignments;
        // TODO: finish and uncomment above parts if this is finished and tested
        //CompilingBooleanCastExpressions;
        TypeChecking;
        print;
    }
}; 

//TODO: remove when done, these are common commands:
// make
// ./civicc ../test/basic/check_success/binops.cvc
// yacc -Wcounterexamples parser.y
// This is how you can print a memory address: printf("variable A is at address: %p\n", (void*)&FUNDEF_NAME(initFunDefNode));

//**********************************************************************************************************************************************
// TODO later: Create separate traversal to convert for loop to while loop, easier after ContextAnalysis, but when to do it????
// TODO: see renameforidentifiers, renaming of variable in nested for loop does not go well, ask in the lesson to a good TA or Simon!
// it is with this file: ./civicc ../test/basic/functional/for_to_while.cvc 

// TODO: check with a TA if milestone 6 is working correctly: regular assignments traversal.
// TODO: segmentation fault/invalid pointer error there, why I cannot understand, i checked everything if it is NULL and prints, etc
// TODO: milestone 6, what to do with for, if anything, no need to do anything right???
// TODO: also ask when this traversal should be performed, before ContextAnalysis or after, etcetera

// TODO: typechecking, ask TA what to do with Cast and if everything is correct for the rest (so also return statement??)

// TODO: milestone 10, what to do with funcalls? And how to do the rest: create new node: TernaryOperator, see inbox message


//TODO: ask what to do with following milestones: milestone for week 7: 12 and 13
// create a pass CodeGeneration with all the traversals in it and where to find what to do???
// And how to start and how to test, etc.





// ************************************************************************************************************************************
// milestones 8 and 11 are only for extensions!
// TODO: for type checking see slides Semantic analysis for implementation hint on type checking!
// TODO: see chapter 4: Expression language for types and other information for typechecking milestones!
// Explanation on type checking: 

// milestone 9:
// || wordt lazy geevalueerd
// voor bool operators een apart iets, dus || &&. Maak daar een ternary node voor
// Dus eig die dingen omvormen in ternary statements
// Example:
// funcCallA() || funcallb()
// Als funCallA() true returned dan zou funcallb() niet uitgevoerd hoeven worden (als die side effects heeft is dat slecht)
// Traversal hoeft dan alleen over de binops te gaan en dan de logicoperators van Binop

// milestone 10:
// in assembly worden booleans anders afgehandeld
// Er zijn geen assembly instructions om van en naar booleans te casten
// Dit moet je dus zelf gaan doen met de cijfers
// cast van int naar bool moet dan bijv een > 0 vergelijking, etc en andersom
// traversal gaat over de Cast nodes

traversal Print {
    uid = PRT
};

// The ContextAnalysis phase is mainly used to create Symbol tables
phase ContextAnalysis {
    actions {
        /*
        This traversal systematicly rename all the identifiers in for loops and save it to the node.
        This is very handy in the creation of symbol tables because you can then just
        create symbol table entries for the identifiers in for loops without special operations.
        */
        traversal RenameForIdentifiers {
            uid = RFI,
            // Also rename all the occurrences of the for variable
            nodes = { For, FunCall, Assign, Var, VarLet }
        };

        // Create Variable Symboltables, linking will be done in a separate traversal
        traversal CreateVariableSymbolTableEntries {
            uid = CVS,
            nodes = { 
                // Program to link first symbol table entries of var and fun
                Program,
                // FunDef to use for the linking to the first SteVar 
                FunDef,
                // FunBody to traverse the VarDecls and Stmts
                FunBody, 
                // These nodes are used to create new Symbol Table entries
                GlobDecl, GlobDef, VarDecl, Param, For
            }
        };
        
        // Create Function Symboltables, linking will be done in a separate traversal
        traversal CreateFunctionSymbolTableEntries {
            uid = CFS,
            nodes = {
                // Program to link first symbol table entries of var and fun
                Program,
                // FunDef to use for creating a new SteFun 
                FunDef,
                // Param node (= LinkedList) to link the params of a FunDef
                Param
            }
        };

        // This traversal links all the Var, VarLet and FunCall occurrences to the correct Ste
        traversal LinkSymbolTableEntries {
            uid = LSTE,
            nodes = { 
                // Program to save the global chain of SteVar and SteFun and going to the right traversal functions
                Program,
                // FunDef and FunBody to use for saving the current chain and going to the right traversal functions
                FunDef, 
                // These nodes are used to update their link once they occur in a program
                Var, Varlet, FunCall
            }
        };
    }
};

// This traversal should transform Variable Initialisations into Regular Assignments
traversal RegularAssignments {
    uid = RA,
    nodes = { Program, Decls, GlobDef, FunBody, VarDecl, For}
};

// The TypeChecking phase is used to check all the types
phase TypeChecking {
    actions {
        // This traversal is used for type checking, such as matching assignments and funcall types
        traversal TypeMatchingAssignmentsFunCalls {
            uid = TMAF,
            nodes = {
                /*
                    These nodes are used for checking the types
                */
                // Foreach function definition
                FunDef,
                // Traverse into the function body
                FunBody,
                // Case assignment: Infer expression type. Compare with variable type
                Assign,
                // Case if-then-else: Infer type of predicate expression: Boolean? 
                // Traverse into then-branch. Traverse into else-branch
                IfElse,
                // Case while-/do-loop: Infer type of predicate expression: Boolean? Traverse into loop body
                While, DoWhile,
                // Case for-loop: Infer types of bound/step expressions: Integer? Traverse into loop body
                For,
                // Case return: ...
                Return,
                // Then continue with next statement...
                /*
                    These nodes are used to infer the types of the Expression
                */
                // Case FunCall: Foreach argument expression: Infer argument type
                // Compare with corresponding parameter type. Yield function return type
                FunCall, Exprs,
                // TODO: what to do with Cast???
                Cast,
                // Case BinOp: Infer left operand type. Infer right operand type. Yield operator result type
                BinOp,
                // Case MonOp: Infer operand type. Yield operator result type
                Monop,
                Var,
                // Case IntConstant: Yield int
                Num,
                // Case FloatConstant: Yield float
                Float,
                // Case BoolConstant: Yield bool
                Bool
            }
        };
    }
};

// This traversal should transform cast expressions with Boolean argument or result value
// into semantically equivalent non-cast expressions (milestone 10)
traversal CompilingBooleanCastExpressions {
    uid = CBCE,
    //TODO: is this correct?
    // It traverses all Cast expressions and turns boolean arguments/results into Constants (Float,Num,Bool)
    nodes = { Cast }
};

enum Type {
    // T_ collides with bison/flex generated stuff.
    prefix = CT,
    values {
        int, float, bool, void
    }
};

enum MonOpEnum {
    prefix = MO,
    values {
        // logical negation (!, MO_not), used for boolean values (true, false)
        // unary minus (-, MO_neg), arithmetic negation, used for arithmetic values (=numbers, etc)
        not, neg
    }
};

enum BinOpEnum {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

nodeset Constants = {Float, Bool, Num};

nodeset Operations = {Binop, Monop};

nodeset Decl = {GlobDef, GlobDecl, FunDef};

nodeset Vars = {VarDecl, Var, VarLet};

nodeset Expr = {Cast, FunCall, Var, ArrExpr} | (Constants | Operations);

nodeset Stmt = {Assign, ExprStmt, IfElse, While, DoWhile, For, Return};

// Link is used for the Symbol table to link a node to the symbol table
nodeset Link = {SteVar, SteFun};
// Link is voor na de symbol table om de symbol table entry te linken met de node (Var, Varlet, Funcall)

root node Program {
    children {
        Decls decls { constructor, mandatory }
    },

    attributes {
        // Contains first global symbol occuring (can be used for linking)
        // No need for constructor because it is set only later on in ContextAnalysis
        SteVar first_ste_variables,
        SteFun first_ste_functions
    }
};

node Decls {
    children {
        Decl decl { constructor },
        Decls next { constructor }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

// This is for the array expression, which is extension 2 and 3
node ArrExpr {
    children {
        Exprs exprs { constructor, mandatory }
    }
};

// Ids are only used for array extensions (= arr[m,n] m and n are Ids), so not yet used
node Ids {
    children {
        Ids next   
    },
    attributes {
        string name
    }
};

node ExprStmt {
    children {
        Expr expr { constructor, mandatory }
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

// (= later on, same as Var and VarLet, such as void foo(){}; return foo();, foo in return is the FunCall)
node FunCall {
    children {
        Exprs args { constructor }
    },
    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Cast {
    children {
        Expr expr {constructor, mandatory }
    }, 
    attributes {
        Type type {constructor }
    }
};

// Used for first extension: nested functions
node FunDefs {
    children {
        FunDef fundef { constructor, mandatory },
        FunDefs next
    }
};

// This ast uses the FunDef node for both the function definition and the function declaration. 
// A function declaration is simply represented as a FunDef node without a FunBody.
// FunHeader not necessary because it has no added value for the ast, first param could be FunHeader.
node FunDef {
    children {
        FunBody body { constructor },
        Param params { constructor }
    },
    attributes {
        Type type { constructor },
        string name { constructor, mandatory },
        bool export { constructor },
        // Link to its own symbol table
        SteFun symbol_table,
        // Link to first symbol table of this functions scope
        SteVar first_ste_variables
        // No need to do anything with EXTERN for the FunDec because they are always external!
    }
};

// local_fundefs is used for nested function definitions
node FunBody {
    children {
        VarDecl decls { constructor },
        // local_fundefs is for the first extension, ignore for now
        FunDefs local_fundefs,
        Stmts stmts { constructor }
    }
};

node IfElse {
    children {
        Expr cond { constructor, mandatory },
        Stmts then { constructor },
        Stmts else_block { constructor }
    }
};

node While {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node DoWhile {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node For {
    children {
        Expr start_expr { constructor, mandatory },
        Expr stop { constructor, mandatory },
        Expr step { constructor },
        Stmts block { constructor }
    },

    attributes {
        string var { constructor }
    }
};

node GlobDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims
    },

    attributes {
        Type type { constructor },
        string name { constructor }
    }
};

node GlobDef {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor }
    },

    attributes {
        Type type { constructor },
        string name { constructor },
        bool export { constructor }
    }
};

node Param {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims { constructor },
        Param next { constructor }
    },

    attributes {
        string name { constructor, mandatory },
        Type type { constructor }
    }
};

node VarDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor },
        VarDecl next { constructor }
    },

    attributes {
        string name { constructor },
        Type type { constructor }
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    }, 

    attributes {
        BinOpEnum op { constructor },
        // Save the infered operator type in typechecking in the node to use in code generation later
        Type operator_type_signature
    }
};

node Monop {
    children {
        Expr operand { constructor, mandatory }
    },

    attributes {
        MonOpEnum op { constructor },
        // Save the infered operator type in typechecking in the node to use in code generation later
        Type operator_type_signature
    }
};

// Variable in assignment (= later on, such as int a = 5; a = 7, a is the VarLet).
node VarLet {
    children {
        // Indices is used for extensions, so leave it for now
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

// Variable in an expression (= later on, such as int d = a * 5, a is the Var).
node Var {
    children {
        // NOT used currently, indices is for the array extensions
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};


// This is the node for a Symbol table chain for variables
node SteVar {
    children {
        // Parent points to a higher nesting level
        SteVar parent { constructor },
        // LinkedList data structure for next symbol table
        SteVar next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor }
    }
};

// This is the node for a Symbol table chain for functions. Every function definition gets its own symbol table.
node SteFun {
    children {
        // Parent wijst naar hogere nesting level
        // TODO: with basic it can just be NULL always in creation, so set to null in traversal function!
        SteFun parent { constructor },
        // LinkedList data structure for next symbol table
        SteFun next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor },
        // Params is the LinkedList from the FunDef, should contain the first value of 
        // the FunDef params. From the first value the LinkedList chain can be followed.
        Param params { constructor }
    }
};
