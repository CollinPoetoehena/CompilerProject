start phase RootPhase {
    actions {
        pass SPdoScanParse;
        ContextAnalysis;
        print;
    }
};

traversal Print {
    uid = PRT
};

traversal ContextAnalysis {
    uid = CA,
    // Program and FunBody to build new symbol tables (new scopes)
    // These nodes are above the others so will be traversed first
    // Var, Varlet and FunCall to fill a symbol table
    nodes = {Program, FunBody, Var, Varlet, FunCall}
};

enum SymbolTableType {
    // Can have two types, variable or function
    prefix = STT,
    values {
        var, varlet, funcall
    }
};

enum Type {
    // T_ collides with bison/flex generated stuff.
    prefix = CT,
    values {
        int, float, bool, void
    }
};

enum MonOpEnum {
    prefix = MO,
    values {
        not, neg
    }
};

enum BinOpEnum {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

nodeset Constants = {Float, Bool, Num};

nodeset Operations = {Binop, Monop};

nodeset Decl = {GlobDef, GlobDecl, FunDef};

nodeset Vars = {VarDecl, Var, VarLet};

nodeset Expr = {Cast, FunCall, Var, ArrExpr} | (Constants | Operations);

nodeset Stmt = {Assign, ExprStmt, IfElse, While, DoWhile, For, Return};

// Link is used for the Symbol table to link a node to the symbol table
nodeset Link = {Ste};
// Link is voor na de symbol table om de symbol table entry te linken met de node (Var, Varlet, Funcall)

root node Program {
    children {
        Decls decls { constructor, mandatory }
    }
};

node Decls {
    children {
        Decl decl { constructor, mandatory },
        Decls next { constructor }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

// This is for the array expression, which is extension 2 and 3
node ArrExpr {
    children {
        Exprs exprs { constructor, mandatory }
    }
};

// Ids are only used for array extensions (= arr[m,n] m and n are Ids), so not yet used
node Ids {
    children {
        Ids next   
    },
    attributes {
        string name
    }
};

node ExprStmt {
    children {
        Expr expr { constructor, mandatory }
    }
};

node Return {
    children {
        Expr expr { constructor }
    }
};

node FunCall {
    children {
        Exprs args { constructor }
    },
    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Cast {
    children {
        Expr expr {constructor, mandatory }
    }, 
    attributes {
        Type type {constructor }
    }
};

// Used for first extension: nested functions
node FunDefs {
    children {
        FunDef fundef { constructor, mandatory },
        FunDefs next
    }
};

// This ast uses the FunDef node for both the function definition and the function declaration. 
// A function declaration is simply represented as a FunDef node without a FunBody.
// FunHeader not necessary because it has no added value for the ast, first param could be FunHeader.
node FunDef {
    children {
        FunBody body { constructor },
        Param params { constructor }
    },
    attributes {
        Type type { constructor },
        string name { constructor, mandatory },
        bool export { constructor }
        // No need to do anything with EXTERN for the FunDec because they are always external!
    }
};

// local_fundefs is used for nested function definitions
node FunBody {
    children {
        VarDecl decls { constructor },
        // local_fundefs is for the first extension, ignore for now
        FunDefs local_fundefs,
        Stmts stmts { constructor }
    }
};

node IfElse {
    children {
        Expr cond { constructor, mandatory },
        Stmts then { constructor },
        Stmts else_block { constructor }
    }
};

node While {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node DoWhile {
    children {
        Expr cond { constructor, mandatory },
        Stmts block { constructor }
    }
};

node For {
    children {
        Expr start_expr { constructor, mandatory },
        Expr stop { constructor, mandatory },
        Expr step { constructor },
        Stmts block { constructor }
    },

    attributes {
        string var { constructor }
    }
};

node GlobDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims
    },

    attributes {
        Type type { constructor },
        string name { constructor }
    }
};

node GlobDef {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor }
    },

    attributes {
        Type type { constructor },
        string name { constructor },
        bool export { constructor }
    }
};

node Param {
    children {
        // Dimensions for array extension 3, leave for now
        Ids dims { constructor },
        Param next { constructor }
    },

    attributes {
        string name { constructor, mandatory },
        Type type { constructor }
    }
};

node VarDecl {
    children {
        // Dimensions for array extension 3, leave for now
        Exprs dims { constructor },
        Expr init { constructor },
        VarDecl next { constructor }
    },

    attributes {
        string name { constructor },
        Type type { constructor }
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    }, 

    attributes {
        BinOpEnum op { constructor }
    }
};

node Monop {
    children {
        Expr operand { constructor, mandatory }
    },

    attributes {
        MonOpEnum op { constructor }
    }
};

// Variable in assignment.
node VarLet {
    children {
        // Indices is used for extensions, so leave it for now
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

// Variable in an expression.
node Var {
    children {
        Exprs indices
    }, 

    attributes {
        string name { constructor },
        Link ste_link
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};

// Symbol table entry
node Ste {
    // variablen en functies
    children {
        // LinkedList data structure for next symbol table
        Ste next { constructor }
    }, 

    attributes {
        string name { constructor },
        Type type { constructor },
        int nesting_level { constructor },
        SymbolTableType symbol_type { constructor }
    }
};
// TODO: milestone 5 symbol table
// Each symbol table entry would feature the name of the variable as a character string, 
// its type as well as its nesting level (starting with zero for the global context)

// basic heeft 2 scopes, global en in een funcall
// LinkedList is dan het handigst, alle functies hebben zijn eigen symbol table
// Alles die de AST ombouwt is een traversal
// Dus Context analysis (Symbol table bouwen) en TypeChecking zijn traversals

// TODO: milestone 6
// This needs to be a separate traversal as well
// int a = expr;
// milestone 6 is loskoppelen van die expr van een VarDecl, je knipt hem dus van de boom after
// en weer aan de boom, dit is handig uiteindelijk voor code generation
