%{

/*
The lexer reads input text and generates a sequence of tokens. 
The parser then reads this sequence of tokens and uses it to build an abstract syntax tree (AST) 
representing the structure of the input.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "palm/memory.h"
#include "palm/ctinfo.h"
#include "palm/dbug.h"
#include "palm/str.h"
#include "ccngen/ast.h"
#include "ccngen/enum.h"
#include "global/globals.h"

static node_st *parseresult = NULL;
extern int yylex(); /* get next token, no more input returns 0 */
static int yyerror( char *errname); /* prints grammar violation message */
extern FILE *yyin;
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc);

// To define debuuging define these variables and do yydebug = 1 before yyparse() at the end
// #define YYDEBUG 1
// #define parse.trace
%}

/*  
%union is used to define the different types of values that the parser is expected to handle.
The %union declaration allows you to specify the types of the values associated with the tokens and nonterminals in the grammar, 
which can be used in the semantic actions to perform operations on those values.

First part is the C type.
Second part is the type that the parser will handle.
*/
%union {
 char               *id;
 int                 cint;
 float               cflt;
 enum Type           ctype;
 node_st             *node;
}

%locations

%token BRACKET_L BRACKET_R COMMA SEMICOLON CURLYBRACE_L CURLYBRACE_R
%token MINUS PLUS STAR SLASH PERCENT LE LT GE GT EQ NE OR AND 
%token EXCLAMATION
%token TRUEVAL FALSEVAL LET
%token INTTYPE FLOATTYPE BOOLTYPE VOIDTYPE

%token <cint> NUM
%token <cflt> FLOAT
%token <id> ID

%token IF ELSE WHILE DO FOR RETURN EXTERN EXPORT

/* 
The %type section is used to define the types of values that can be generated by the parser
See union section, <node> stands for node_st, which is a generic type for an ast node
*/
// Top nodes
%type <node> program decls decl

// Function nodes
%type <node> funbody param fundef funcall

// Statement nodes
%type <node> stmts stmt
%type <node> ifelse while dowhile for return

%type <node> intval floatval boolval constant expr exprs
%type <node> assign varlet var
%type <node> globdecl globdef vardecl

%type <node> block

// Enum types
%type <ctype> type

// Yacc version: Bison 3.8.2 supports %precedence, so %precedence warning can be ignored
%precedence THEN
%precedence ELSE

// Precedence rules, lowest on top, highest at the bottom
// Precedence rules in C https://en.cppreference.com/w/c/language/operator_precedence
%left COMMA
  // Simple assignment (right associative)
%right LET
  // Logical OR 
%left OR
  // Logical AND
%left AND
  // Relational operators 
%left EQ NE
%left GT GE LT LE
  // Addition and subtraction
%left MINUS PLUS
  // Multiplication, division, and remainder
%left STAR SLASH PERCENT
  // Monary operators (right associative)
  // MONOP_MINUS is a created precedence rule for monary operator -
  // TYPE_CAST is a created precedence rule for a type cast
%right MONOP_MINUS EXCLAMATION TYPECAST
  // Function call
%left FUNCTIONCALL

/* 
Starting rule for the parser, in this case the program rule 
From here it starts expanding. So, everything needs to be linked
When coding grammars, you can change it to the grammar rule you are trying to test.
This will give warnings from useless grammars because they are not linked, but you can ignore that.
*/
%start program

%%
// All the grammar rules are specified here
program: decls
         {
           parseresult = ASTprogram($1);
         }
         ;

decls: decl decls
        {
          // $$ = means what you return to coconut
          $$ = ASTdecls($1, $2);
        }
      | decl
        {
          // Next is NULL
          $$ = ASTdecls($1, NULL);
        }
      ;

decl: fundef
        {
          $$ = $1;
        }
      | globdecl
        {
          $$ = $1;
        }
      | globdef
        {
          $$ = $1;
        }
      ;

// No FunHeader node in main.ccn because funHeader return type 
// is encoded in the param, such as first param is return type
// FunDec is also specified in FunDef node
fundef: EXPORT type ID BRACKET_L param BRACKET_R CURLYBRACE_L funbody CURLYBRACE_R
        {
          $$ = ASTfundef($8, $5, $2, $3, true);
        }
      | EXPORT type ID BRACKET_L BRACKET_R CURLYBRACE_L funbody CURLYBRACE_R
        {
          // Empty param
          $$ = ASTfundef($7, NULL, $2, $3, true);
        }
      | type ID BRACKET_L param BRACKET_R CURLYBRACE_L funbody CURLYBRACE_R
        {
          $$ = ASTfundef($7, $4, $1, $2, false);
        }
      | type ID BRACKET_L BRACKET_R CURLYBRACE_L funbody CURLYBRACE_R
        {
          // Empty param
          $$ = ASTfundef($6, NULL, $1, $2, false);
        }
      | EXTERN type ID BRACKET_L param BRACKET_R
        {
          // Empty funbody
          // No need to do anything with EXTERN for the FunDec because they are always external!
          $$ = ASTfundef(NULL, $5, $2, $3, true);
        }
      | EXTERN type ID BRACKET_L BRACKET_R
        {
          // Empty param and empty funbody
          // No need to do anything with EXTERN for the FunDec because they are always external!
          $$ = ASTfundef(NULL, NULL, $2, $3, true);
        }
      ;

globdecl: EXTERN type ID SEMICOLON
         {
          // ID has the value that the lexer put into it with STRCopy(yytext)
           $$ = ASTglobdecl($2, $3);
         }
        ;

globdef: EXPORT type ID LET expr SEMICOLON
        {
          $$ = ASTglobdef(NULL, $5, $2, $3, true);
        }
      | type ID LET expr SEMICOLON
        {
          $$ = ASTglobdef(NULL, $4, $1, $2, false);
        }
      | EXPORT type ID SEMICOLON 
        {
          $$ = ASTglobdef(NULL, NULL, $2, $3, true);
        }
      | type ID SEMICOLON 
        {
          $$ = ASTglobdef(NULL, NULL, $1, $2, false);
        }
      ;

param: type ID COMMA param
      {
        $$ = ASTparam(NULL, $4, $2, $1);
      }
     | type ID
      {
        $$ = ASTparam(NULL, NULL, $2, $1);
      }
    ;

funbody: vardecl stmts
        {
          $$ = ASTfunbody($1, $2);
        }
      | vardecl
        {
          $$ = ASTfunbody($1, NULL);
        }
      | stmts
        {
          $$ = ASTfunbody(NULL, $1);
        }
      | 
        {
          $$ = ASTfunbody(NULL, NULL);
        }
      ;

vardecl: type ID SEMICOLON
        {
          // dims expr is NULL, initial expr is NULL, next is NULL, name is ID, type is type
          $$ = ASTvardecl(NULL, NULL, NULL, $2, $1);
        }
      | type ID LET expr SEMICOLON
        {
          $$ = ASTvardecl(NULL, $4, NULL, $2, $1);
        }
      | type ID SEMICOLON vardecl
        {
          $$ = ASTvardecl(NULL, NULL, $4, $2, $1);
        }
      | type ID LET expr SEMICOLON vardecl
        {
          $$ = ASTvardecl(NULL, $4, $6, $2, $1);
        }
      ;

stmts: stmt stmts
        {
          $$ = ASTstmts($1, $2);
        }
      | stmt
        {
          $$ = ASTstmts($1, NULL);
        }
      ;

stmt: assign
      {
         $$ = $1;
      }
    | ifelse
      {
        $$ = $1;
      }
    | while
      {
        $$ = $1;
      }
    | dowhile
      {
        $$ = $1;
      }
    | for
      {
        $$ = $1;
      }
      ;
    | return
      {
        $$ = $1;
      }
    | funcall SEMICOLON %prec FUNCTIONCALL
      {
        $$ = ASTexprstmt($1);
        // Funcall belongs in expr and stmt, in stmt it has a SEMICOLON
      }
    ;
// %prec LOWER_THAN_ELSE (== nonassoc) makes sure that the else belongs to the closest if statement
ifelse: IF BRACKET_L expr BRACKET_R block %prec THEN
        {
          $$ = ASTifelse($3, $5, NULL);
        }
      | IF BRACKET_L expr BRACKET_R block ELSE block 
        {
          $$ = ASTifelse($3, $5, $7);
        }
      ;
while: WHILE BRACKET_L expr BRACKET_R block
       {
        $$ = ASTwhile($3, $5);
       }
      ;
dowhile: DO block WHILE BRACKET_L expr BRACKET_R SEMICOLON
          {
           $$ = ASTdowhile($5, $2);
          }
        ;
for: FOR BRACKET_L INTTYPE ID LET expr COMMA expr COMMA expr BRACKET_R block
     {
      $$ = ASTfor($6, $8, $10, $12, $4);
     }
    | FOR BRACKET_L INTTYPE ID LET expr COMMA expr BRACKET_R block
     {
      // No step means NULL, which will be used as + 1, this is coded somewhere else
      $$ = ASTfor($6, $8, NULL, $10, $4);
     }
    ;
return: RETURN SEMICOLON
        {
          $$ = ASTreturn(NULL);
        }
      | RETURN expr SEMICOLON
        {
          $$ = ASTreturn($2);
        }
      ;

// Block always needs to return ASTstmts, because it is used in the statements as a Stmts node type 
block: CURLYBRACE_L stmts CURLYBRACE_R
      {
        $$ = $2;
      }
    | stmt
      {
        $$ = ASTstmts($1, NULL);
      }
    ;

funcall: ID BRACKET_L BRACKET_R
        {
          // No arguments
          $$ = ASTfuncall(NULL, $1);
        }
      | ID BRACKET_L exprs BRACKET_R 
        {
          $$ = ASTfuncall($3, $1);
        }
      ;

// For precedence of operators call them with the lexer token and not another rule such as binop
expr: BRACKET_L expr BRACKET_R
      {
        $$ = ASTexprstmt($2);
      }
    | expr[left] PLUS expr[right]
      {
        $$ = ASTbinop($left, $right, BO_add);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] MINUS expr[right]
      {
        $$ = ASTbinop($left, $right, BO_sub);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] SLASH expr[right]
      {
        $$ = ASTbinop($left, $right, BO_div);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] STAR expr[right]
      {
        $$ = ASTbinop($left, $right, BO_mul);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] PERCENT expr[right]
      {
        $$ = ASTbinop($left, $right, BO_mod);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] LE expr[right]
      {
        $$ = ASTbinop($left, $right, BO_le);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] LT expr[right]
      {
        $$ = ASTbinop($left, $right, BO_lt);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] GE expr[right]
      {
        $$ = ASTbinop($left, $right, BO_ge);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] GT expr[right]
      {
        $$ = ASTbinop($left, $right, BO_gt);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] EQ expr[right]
      {
        $$ = ASTbinop($left, $right, BO_eq);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] OR expr[right]
      {
        $$ = ASTbinop($left, $right, BO_or);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] AND expr[right]
      {
        $$ = ASTbinop($left, $right, BO_and);
        AddLocToNode($$, &@left, &@right);
      }
    | expr[left] NE expr[right]
      {
        $$ = ASTbinop($left, $right, BO_ne);
        AddLocToNode($$, &@left, &@right);
      }
    | MINUS expr %prec MONOP_MINUS
      {
        // This MINUS uses the MONOP_MINUS precedence rule
        // arithmetic negation, used for arithmetic values (=numbers, etc)
        $$ = ASTmonop($2, MO_neg);
        // AddLocToNode($$, &@2);
      }
    | EXCLAMATION expr
      {
        // logical negation, used for boolean values (true, false)
        $$ = ASTmonop($2, MO_not);
        // AddLocToNode($$, &@2);
      }
    | BRACKET_L type BRACKET_R expr %prec TYPECAST
      {
        // Type cast
        $$ = ASTcast($4, $2);
      }
    | funcall %prec FUNCTIONCALL
      {
        // Funcall belongs in expr and stmt, in expr it does not have a SEMICOLON
        $$ = $1;
      }
    | var
      {
        $$ = $1;
      }
    | constant
      {
        $$ = $1;
      }
    ;

// exprs has one or an infinite amount of expr
exprs: expr
      {
        $$ = ASTexprs($1, NULL);
      }
     | exprs COMMA expr
      {
        $$ = ASTexprs($3, $1);
      }
     ;

assign: varlet LET expr SEMICOLON
        {
          $$ = ASTassign($1, $3);
        }
      ;

// type non-terminal
// In the Typechecking traversal it checks the types because 
// some nodes cannot have void type for example
type: BOOLTYPE  { $$ = CT_bool; }
    | FLOATTYPE { $$ = CT_float; }
    | INTTYPE   { $$ = CT_int; }
    | VOIDTYPE  { $$ = CT_void; }
    ;

// Variable in assignment.
varlet: ID
        {
          $$ = ASTvarlet($1);
          AddLocToNode($$, &@1, &@1);
        }
      ;

// Variable in an expression.
var: ID
        {
          $$ = ASTvar($1);
          AddLocToNode($$, &@1, &@1);
        }
      ;

constant: floatval
          {
            // Assign the value of the floatval grammar rule AST creation to this constant node type
            $$ = $1;
          }
        | intval
          {
            $$ = $1;
          }
        | boolval
          {
            $$ = $1;
          }
        ;

floatval: FLOAT
           {
             $$ = ASTfloat($1);
           }
         ;

intval: NUM
        {
          $$ = ASTnum($1);
        }
      ;

boolval: TRUEVAL
         {
           $$ = ASTbool(true);
         }
       | FALSEVAL
         {
           $$ = ASTbool(false);
         }
       ;
%%

/* Add location tracking information to a node in the parse tree */
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc)
{
    // Needed because YYLTYPE unpacks later than top-level decl.
    YYLTYPE *loc_b = (YYLTYPE*)begin_loc;
    YYLTYPE *loc_e = (YYLTYPE*)end_loc;
    NODE_BLINE(node) = loc_b->first_line;
    NODE_BCOL(node) = loc_b->first_column;
    NODE_ELINE(node) = loc_e->last_line;
    NODE_ECOL(node) = loc_e->last_column;
}

/*
yyerror is called by the parser when it encounters a syntax error in the input file.

yyerror should print out user-friendly error messages when there is a syntax error in the input file.
And it should terminate the program.

It takes one argument, which is the char * describing the error message (char * == string type).
CTI (Control and Information) is used to print out the error message with the line number 
and column number where the error occurred. Then  the program is aborted using CTIabortOnError.
*/
static int yyerror( char *error)
{
  CTI(CTI_ERROR, true, "line %d, col %d\nError parsing source code: %s\n",
            global.line, global.col, error);
  CTIabortOnError();
  return( 0);
}

node_st *SPdoScanParse(node_st *root)
{
    DBUG_ASSERT(root == NULL, "Started parsing with existing syntax tree.");
    yyin = fopen(global.input_file, "r");
    if (yyin == NULL) {
        CTI(CTI_ERROR, true, "Cannot open file '%s'.", global.input_file);
        CTIabortOnError();
    }
    // To allow debugging define yydebug = 1; and define variables at the top
    // yydebug = 1;
    yyparse();
    return parseresult;
}
