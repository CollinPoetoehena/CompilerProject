%{

/*
The lexer reads input text and generates a sequence of tokens. 
The parser then reads this sequence of tokens and uses it to build an abstract syntax tree (AST) 
representing the structure of the input.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "palm/memory.h"
#include "palm/ctinfo.h"
#include "palm/dbug.h"
#include "palm/str.h"
#include "ccngen/ast.h"
#include "ccngen/enum.h"
#include "global/globals.h"

static node_st *parseresult = NULL;
extern int yylex(); /* get next token, no more input returns 0 */
static int yyerror( char *errname); /* prints grammar violation message */
extern FILE *yyin;
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc);


%}

/*  
%union is used to define the different types of values that the parser is expected to handle.
The %union declaration allows you to specify the types of the values associated with the tokens and nonterminals in the grammar, 
which can be used in the semantic actions to perform operations on those values.

First part is the C type.
Second part is the type that the parser will handle.
*/
%union {
 char               *id;
 int                 cint;
 float               cflt;
 enum Type           ctype;
 enum BinOpEnum     cbinop;
 enum MonOpEnum     cmonop;
 node_st             *node;
}

%locations

%token BRACKET_L BRACKET_R COMMA SEMICOLON
%token MINUS PLUS STAR SLASH PERCENT LE LT GE GT EQ NE OR AND EXCLAMATION
%token TRUEVAL FALSEVAL LET
%token INTTYPE FLOATTYPE BOOLTYPE VOIDTYPE

%token <cint> NUM
%token <cflt> FLOAT
%token <id> ID

%token IF ELSE WHILE DO FOR RETURN EXTERN EXPORT

/* 
The %type section is used to define the types of values that can be generated by the parser
See union section, <node> stands for node_st, which is a generic type for an ast node
*/
%type <node> intval floatval boolval constant expr
%type <node> stmts stmt assign varlet program 
%type <node> globdecl vardecl globdef
%type <cbinop> binop
%type <ctype> type
%type <cmonop> monop

/* 
Starting rule for the parser, in this case the program rule 
From here it starts expanding. So, everything needs to be linked
When coding grammars, you can change it to the grammar rule you are trying to test.
This will give warnings from useless grammars because they are not linked, but you can ignore that.
*/
// %start program
%start globdef

%%
// All the grammar rules are specified here

program: stmts
         {
           parseresult = ASTprogram($1);
         }
         ;

stmts: stmt stmts
        {
          $$ = ASTstmts($1, $2);
        }
      | stmt
        {
          $$ = ASTstmts($1, NULL);
        }
        ;

stmt: assign
       {
         $$ = $1;
       }
       ;

assign: varlet LET expr SEMICOLON
        {
          $$ = ASTassign($1, $3);

        }
        ;

varlet: ID
        {
          $$ = ASTvarlet($1);
          AddLocToNode($$, &@1, &@1);
        }
        ;


// OLD EXPR THAT WAS STANDARD IN HERE
// expr: constant
//       {
//         $$ = $1;
//       }
//     | ID
//       {
//         $$ = ASTvar($1);
//       }
//     | BRACKET_L expr[left] binop[type] expr[right] BRACKET_R
//       {
//         $$ = ASTbinop( $left, $right, $type);
//         AddLocToNode($$, &@left, &@right);
//       }
//     ;

expr: BRACKET_L expr[left] binop[type] expr[right] BRACKET_R
      {
        $$ = ASTbinop( $left, $right, $type);
        AddLocToNode($$, &@left, &@right);
      }
    | BRACKET_L type BRACKET_R expr
      {
        printf("expr with basic type \n");
      }
    | ID BRACKET_L args BRACKET_R
      {
        printf("ID expr with args \n");
      }
    | ID
      {
        $$ = ASTvar($1);
        printf("ID expr \n");
      }
    | constant
      {
        $$ = $1;
        printf("constant expr\n");
      }
    ;

args : expr
     | args COMMA expr
     ;

// type non-terminal
// TODO: because this type also has void, with type checking there needs to be a check
// if it can include a void type, but this is later on!
type: BOOLTYPE  { $$ = CT_bool; }
    | FLOATTYPE { $$ = CT_float; }
    | INTTYPE   { $$ = CT_int; }
    | VOIDTYPE  { $$ = CT_void; }
    ;

monop: MINUS    
       { 
        // arithmetic negation, used for arithmetic values (=numbers, etc)
        $$ = MO_neg; 
        printf("arithmetic negation (-) \n");
       }
      | EXCLAMATION
       {
        // logical negation, used for boolean values (true, false)
        $$ = MO_not;
        printf("logical negation (!) \n");
       }

constant: floatval
          {
            $$ = $1;
          }
        | intval
          {
            $$ = $1;
          }
        | boolval
          {
            $$ = $1;
          }
        ;

floatval: FLOAT
           {
             $$ = ASTfloat($1);
           }
         ;

intval: NUM
        {
          $$ = ASTnum($1);
        }
      ;

boolval: TRUEVAL
         {
           $$ = ASTbool(true);
         }
       | FALSEVAL
         {
           $$ = ASTbool(false);
         }
       ;

binop: PLUS      { $$ = BO_add; }
     | MINUS     { $$ = BO_sub; }
     | STAR      { $$ = BO_mul; }
     | SLASH     { $$ = BO_div; }
     | PERCENT   { $$ = BO_mod; }
     | LE        { $$ = BO_le; }
     | LT        { $$ = BO_lt; }
     | GE        { $$ = BO_ge; }
     | GT        { $$ = BO_gt; }
     | EQ        { $$ = BO_eq; }
     | OR        { $$ = BO_or; }
     | AND       { $$ = BO_and; }
     ;

globdef: EXPORT type assign
        {
          printf("glob def with export and assignment (= expr)\n");
        }
      | type assign 
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def type and assign\n");
        }
      | EXPORT type ID SEMICOLON 
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def with export\n");
        }
      | type ID SEMICOLON 
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def without export\n");
        }
      ;

vardecl: type ID SEMICOLON
        {
          printf("var decl\n");
        }
      | type assign
        {
          printf("var decl with assign\n");
        }
      ;

globdecl: EXTERN type ID SEMICOLON
         {
          // $ refereert naar de positie in je regel
          // $$ = betekent wat die teruggeeft aan coconut
          // in ID zit de waarde die je lexer daarin heeft gezet met STRCopy(yytext)
           $$ = ASTglobdecl();
           printf("global declaration\n");
         }
         ;
%%

/* Add location tracking information to a node in the parse tree */
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc)
{
    // Needed because YYLTYPE unpacks later than top-level decl.
    YYLTYPE *loc_b = (YYLTYPE*)begin_loc;
    YYLTYPE *loc_e = (YYLTYPE*)end_loc;
    NODE_BLINE(node) = loc_b->first_line;
    NODE_BCOL(node) = loc_b->first_column;
    NODE_ELINE(node) = loc_e->last_line;
    NODE_ECOL(node) = loc_e->last_column;
}

/*
yyerror is called by the parser when it encounters a syntax error in the input file.

yyerror should print out user-friendly error messages when there is a syntax error in the input file.
And it should terminate the program.

It takes one argument, which is the char * describing the error message (char * == string type).
CTI (Control and Information) is used to print out the error message with the line number 
and column number where the error occurred. Then  the program is aborted using CTIabortOnError.
*/
static int yyerror( char *error)
{
  CTI(CTI_ERROR, true, "line %d, col %d\nError parsing source code: %s\n",
            global.line, global.col, error);
  CTIabortOnError();
  return( 0);
}

node_st *SPdoScanParse(node_st *root)
{
    DBUG_ASSERT(root == NULL, "Started parsing with existing syntax tree.");
    yyin = fopen(global.input_file, "r");
    if (yyin == NULL) {
        CTI(CTI_ERROR, true, "Cannot open file '%s'.", global.input_file);
        CTIabortOnError();
    }
    yyparse();
    return parseresult;
}
