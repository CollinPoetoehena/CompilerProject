%{

/*
The lexer reads input text and generates a sequence of tokens. 
The parser then reads this sequence of tokens and uses it to build an abstract syntax tree (AST) 
representing the structure of the input.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "palm/memory.h"
#include "palm/ctinfo.h"
#include "palm/dbug.h"
#include "palm/str.h"
#include "ccngen/ast.h"
#include "ccngen/enum.h"
#include "global/globals.h"

static node_st *parseresult = NULL;
extern int yylex(); /* get next token, no more input returns 0 */
static int yyerror( char *errname); /* prints grammar violation message */
extern FILE *yyin;
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc);


%}

/*  
%union is used to define the different types of values that the parser is expected to handle.
The %union declaration allows you to specify the types of the values associated with the tokens and nonterminals in the grammar, 
which can be used in the semantic actions to perform operations on those values.

First part is the C type.
Second part is the type that the parser will handle.
*/
%union {
 char               *id;
 int                 cint;
 float               cflt;
 enum Type           ctype;
 node_st             *node;
}

%locations

%token BRACKET_L BRACKET_R COMMA SEMICOLON CURLYBRACE_L CURLYBRACE_R
%token MINUS PLUS STAR SLASH PERCENT LE LT GE GT EQ NE OR AND 
%token EXCLAMATION
%token TRUEVAL FALSEVAL LET
%token INTTYPE FLOATTYPE BOOLTYPE VOIDTYPE

%token <cint> NUM
%token <cflt> FLOAT
%token <id> ID

%token IF ELSE WHILE DO FOR RETURN EXTERN EXPORT

/* 
The %type section is used to define the types of values that can be generated by the parser
See union section, <node> stands for node_st, which is a generic type for an ast node
*/
// Top nodes
%type <node> program decls

// Function nodes
%type <node> funbody param fundef funcall

// Statement nodes
%type <node> stmts stmt
%type <node> ifelse while dowhile for return

%type <node> intval floatval boolval constant expr
%type <node> assign varlet var
%type <node> globdecl vardecl globdef

// Enum types
%type <ctype> type
 //TODO: remove??? because not used anymore because of operator precedences
// %type <cbinop> binop
// %type <cmonop> monop

// Precedence rules, lowest on top, highest at the bottom
// Precedence rules in C https://en.cppreference.com/w/c/language/operator_precedence
%left COMMA
  // Simple assignment (right associative)
%right LET
  // Logical OR 
%left OR
  // Logical AND
%left AND
  // Relational operators 
%left EQ NE
%left GT GE LT LE
  // Addition and subtraction
%left MINUS PLUS
  // Multiplication, division, and remainder
%left STAR SLASH PERCENT
  // Monary operators (right associative)
  // MONOP_MINUS is a separate token
%right MONOP_MINUS EXCLAMATION

/* 
Starting rule for the parser, in this case the program rule 
From here it starts expanding. So, everything needs to be linked
When coding grammars, you can change it to the grammar rule you are trying to test.
This will give warnings from useless grammars because they are not linked, but you can ignore that.
*/
// %start program

%%
// All the grammar rules are specified here
// TODO: operator precedence in expr: https://canvas.uva.nl/courses/36019/discussion_topics/662306
program: decls
         {
          //  parseresult = ASTprogram($1);
         }
         ;

decls: decl decls
        {
          printf("decl and decls\n");
        }
      | decl
        {
          printf("one decl\n");
        }
      ;

// TESTED
decl: fundef
        {
          printf("fundef decl\n");
        }
      | globdecl
        {
          printf("globdecl decl\n");
        }
      | globdef
        {
          printf("globdef decl\n");
        }
      ;

// TESTED
funcall: ID BRACKET_L BRACKET_R SEMICOLON
        {
          printf("fun call without args with semicolon\n");
        }
      | ID BRACKET_L args BRACKET_R SEMICOLON
        {
          printf("fun call with args with semicolon\n");
        }
      | ID BRACKET_L BRACKET_R 
        {
          printf("fun call without args without semicolon\n");
        }
      | ID BRACKET_L args BRACKET_R 
        {
          printf("fun call with args without semicolon\n");
        }
      ;

// TESTED
fundef: EXPORT funheader CURLYBRACE_L funbody CURLYBRACE_R
        {
          printf("fun def with export\n");
        }
      | funheader CURLYBRACE_L funbody CURLYBRACE_R
        {
          printf("fun def without export\n");
        }
      | EXTERN funheader
        {
          printf("fun dec (fundef is also used for a fundec)\n");
        }
      ;

// TESTED
// No FunHeader node in main.ccn because funHeader return type 
// is encoded in the params, such as first param is return type
funheader: type ID BRACKET_L params BRACKET_R
        {
          printf("fun header\n");
        }
      | type ID BRACKET_L BRACKET_R
        {
          printf("fun header without params\n");
        }
        ;

// TESTED
globdecl: EXTERN type ID SEMICOLON
         {
          // $ refereert naar de positie in je regel
          // $$ = betekent wat die teruggeeft aan coconut
          // in ID zit de waarde die je lexer daarin heeft gezet met STRCopy(yytext)
           $$ = ASTglobdecl($2, $3);
           printf("global declaration\n");
         }
        ;

// TESTED
globdef: EXPORT type assign
        {
          printf("glob def with export and assignment (= expr)\n");
        }
      | type assign
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def type and assign\n");
        }
      | EXPORT type ID SEMICOLON 
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def with export\n");
        }
      | type ID SEMICOLON 
        {
          //TODO: how to decide between globdef and vardecl for this part, because == same
          // Can I just do vardecl here??
          printf("glob def without export\n");
        }
      ;

// type non-terminal
// TODO: because this type also has void, with type checking there needs to be a check
// if it can include a void type, but this is later on!
type: BOOLTYPE  { $$ = CT_bool; }
    | FLOATTYPE { $$ = CT_float; }
    | INTTYPE   { $$ = CT_int; }
    | VOIDTYPE  { $$ = CT_void; }
    ;


// TESTED
// Can have 1 or an infinite amount of params
params: param COMMA params
        {
            printf("param with params\n");
        }
      | param
        {
            printf("param\n");
        }
      ;

// TESTED
param: type ID
      {
          printf("fun body with 0 or infinite vardecls and statements\n");
      }
      ;

// TESTED
// FunBody
funbody: vardecls stmts
        {
          printf("fun body with 1 or infinite vardecls and statements\n");
        }
      | vardecls
        {
          printf("fun body with only 1 or infinite vardecls\n");
        }
      | stmts
        {
          printf("fun body with only 1 or infinite statements\n");
        }
      | 
        {
          $$ = NULL;
          printf("empty fun body\n");
        }
      ;

// TESTED
vardecl: type ID SEMICOLON
        {
          // dims expr is NULL, initial expr is var, next is NULL, type is type
          // $$ = ASTvardecl(NULL, $2, NULL, $3);
          printf("var decl\n");
        }
      | type assign
        {
          // $$ = ASTvardecl(NULL, $2, NULL, $3);
          printf("var decl with assign\n");
        }
      ;
// Zero or infinite amount of vardecl
vardecls: vardecl vardecls
         {
           // Probably no action here because the action to the ast is handled in vardecl and VarDecls is not a node!
           printf("vardecls empty\n");
         }
       | vardecl
         {
           printf("one vardecl from vardecls\n");
         }
       ;

// TESTED
stmts: stmt stmts
        {
          $$ = ASTstmts($1, $2);
        }
      | stmt
        {
          $$ = ASTstmts($1, NULL);
        }
      ;

//TODO: finish this statement and ask a TA in the lesson if it is correct.
// TESTED
stmt: assign
      {
         $$ = $1;
      }
    | ID BRACKET_L args BRACKET_R
      {
        printf("ID expr with args for statement grammar \n");
      }
    | ifelse
      {
        printf("ifelse in statement found \n");
      }
    | while
      {
        printf("while in statement found \n");
      }
    | dowhile
      {
        printf("do while in statement found \n");
      }
    | for
      {
        printf("for in statement found \n");
      }
      ;
    | return
      {
        printf("return in statement found \n");
      }
    | funcall
      {
        //TODO: does funcall belong in stmt???
        printf("expr function call\n");
      }
    ;
// TESTED
ifelse: IF BRACKET_L expr BRACKET_R block
        {
          printf("IF without else block \n");
        }
      | IF BRACKET_L expr BRACKET_R block ELSE block
        {
          printf("IF including else block \n");
        }
      ;
// TESTED
while: WHILE BRACKET_L expr BRACKET_R block
               {
                 printf("WHILE statement \n");
               }
             ;
// TESTED
dowhile: DO block WHILE BRACKET_L expr BRACKET_R SEMICOLON
               {
                 printf("DO-WHILE statement \n");
               }
             ;
// TESTED
for: FOR BRACKET_L INTTYPE varlet LET expr COMMA expr COMMA expr BRACKET_R block
               {
                 printf("FOR statement with second expr \n");
               }
              | FOR BRACKET_L INTTYPE varlet LET expr COMMA expr BRACKET_R block
               {
                 printf("FOR statement without second expr \n");
               }
             ;
// TESTED
return: RETURN SEMICOLON
        {
          printf("RETURN statement without expr \n");
        }
      | RETURN expr SEMICOLON
        {
          printf("RETURN statement including expr \n");
        }
      ;

// TESTED
block: CURLYBRACE_L stmts CURLYBRACE_R
      {
        printf("block with curly braces \n");
      }
    | stmt
      {
        printf("stmt block without curly braces \n");
      }
    ;

// For precedence of operators call them with the lexer token and not another rule
expr: BRACKET_L expr BRACKET_R
      {
        printf("expr with brackets \n");
      }
    | expr[left] PLUS expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_add);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] MINUS expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_sub);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] SLASH expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_div);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] STAR expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_mul);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] PERCENT expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_mod);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] LE expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_le);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] LT expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_lt);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] GE expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_ge);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] GT expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_gt);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] EQ expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_eq);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] OR expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_or);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] AND expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_and);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | expr[left] NE expr[right]
      {
        $$ = ASTbinop( $left, $right, BO_ne);
        AddLocToNode($$, &@left, &@right);
        printf("expr binop expr including brackets \n");
      }
    | MINUS expr %prec MONOP_MINUS
      {
        // This MINUS uses the MONOP_MINUS precedence rule
        // arithmetic negation, used for arithmetic values (=numbers, etc)
        $$ = ASTmonop($2, MO_neg);
        // AddLocToNode($$, &@2);
        printf("monop expr including brackets \n");
      }
    | EXCLAMATION expr
      {
        // logical negation, used for boolean values (true, false)
        $$ = ASTmonop($2, MO_not);
        // AddLocToNode($$, &@2);
        printf("expr monop expr including brackets \n");
      }
    | BRACKET_L type BRACKET_R expr
      {
        printf("expr with basic type \n");
      }
    | ID BRACKET_L args BRACKET_R
      {
        printf("ID expr with args \n");
      }
    | ID
      {
        $$ = ASTvar($1);
        printf("ID expr \n");
      }
    | constant
      {
        $$ = $1;
        printf("constant expr\n");
      }
    | funcall
      {
        //TODO: does funcall belong in expr??? 
        printf("expr function call\n");
      }
    | funcall expr
      {
        //TODO: does funcall belong in expr???
        printf("expr function call with expr\n");
      }
    ;

// args has one or an infinite amount of expr
args: expr
     | args COMMA expr
     ;

assign: varlet LET expr SEMICOLON
        {
          $$ = ASTassign($1, $3);
          printf("assign without cast\n");
        }
      | varlet LET BRACKET_L type BRACKET_R expr SEMICOLON
        {
          // no separate cast grammar rule because of conflicts
          $$ = ASTassign($1, $6);
          printf("assign with cast\n");
        }
      ;

// Variable in assignment.
varlet: ID
        {
          $$ = ASTvarlet($1);
          AddLocToNode($$, &@1, &@1);
        }
        ;

// Variable in an expression.
var: ID
        {
          $$ = ASTvar($1);
          AddLocToNode($$, &@1, &@1);
        }
        ;

constant: floatval
          {
            $$ = $1;
          }
        | intval
          {
            $$ = $1;
          }
        | boolval
          {
            $$ = $1;
          }
        ;

floatval: FLOAT
           {
             $$ = ASTfloat($1);
           }
         ;

intval: NUM
        {
          $$ = ASTnum($1);
        }
      ;

boolval: TRUEVAL
         {
           $$ = ASTbool(true);
         }
       | FALSEVAL
         {
           $$ = ASTbool(false);
         }
       ;
%%

/* Add location tracking information to a node in the parse tree */
void AddLocToNode(node_st *node, void *begin_loc, void *end_loc)
{
    // Needed because YYLTYPE unpacks later than top-level decl.
    YYLTYPE *loc_b = (YYLTYPE*)begin_loc;
    YYLTYPE *loc_e = (YYLTYPE*)end_loc;
    NODE_BLINE(node) = loc_b->first_line;
    NODE_BCOL(node) = loc_b->first_column;
    NODE_ELINE(node) = loc_e->last_line;
    NODE_ECOL(node) = loc_e->last_column;
}

/*
yyerror is called by the parser when it encounters a syntax error in the input file.

yyerror should print out user-friendly error messages when there is a syntax error in the input file.
And it should terminate the program.

It takes one argument, which is the char * describing the error message (char * == string type).
CTI (Control and Information) is used to print out the error message with the line number 
and column number where the error occurred. Then  the program is aborted using CTIabortOnError.
*/
static int yyerror( char *error)
{
  CTI(CTI_ERROR, true, "line %d, col %d\nError parsing source code: %s\n",
            global.line, global.col, error);
  CTIabortOnError();
  return( 0);
}

node_st *SPdoScanParse(node_st *root)
{
    DBUG_ASSERT(root == NULL, "Started parsing with existing syntax tree.");
    yyin = fopen(global.input_file, "r");
    if (yyin == NULL) {
        CTI(CTI_ERROR, true, "Cannot open file '%s'.", global.input_file);
        CTIabortOnError();
    }
    yyparse();
    return parseresult;
}
