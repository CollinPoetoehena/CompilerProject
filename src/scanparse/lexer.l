%{

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "ccngen/ast.h"
#include "ccngen/enum.h"
#include "parser.h"
#include "palm/str.h"
#include "global/globals.h"
#include "palm/ctinfo.h"


#define FILTER(token) \
  global.col += yyleng;  \
  return( token);

#define LINEBUF_SIZE 256
#define YY_NO_UNPUT
#define YY_NO_INPUT

static inline void token_action();

/* TODO: Can be removed, because probably you need to handle unterminated comment in the parser */
// int input() {
//     return getchar();
// }
// /* prints grammar violation message */
// void yyerror(const char *s) {
//     fprintf(stderr, "Error: %s\n", s);
// }  
// static void comment(void);

int yycolumn = 1;
#define YY_USER_ACTION token_action();

%}

%p 6000 /* set positions to 6000 */
%e 2000 /* set nodes to 1100 */
%option noyywrap
%option nounput
%option yylineno

  // regular expressions for common lexemes
  // '\' is used to escape a character, in this case the '.'
DIGIT            [0-9]
NONZERO_DIGIT    [1-9]
LETTER           [a-zA-Z]
INTEGER          {DIGIT}+
  // This FLOAT accepts: '123.456', '.456'
FLOAT            ({DIGIT}+\.{DIGIT}*)?
COMMENT_MULTI    \/\*[^*]*\*+([^/*][^*]*\*+)*\/
COMMENT_ONE      \/\/[^\n]*
  // COMMENT          ({COMMENT_ONE}|{COMMENT_MULTI})

%%
  /* Comment on top because that is the first thing you want to scan */
  /*{COMMENT}                  { 
                            printf("Comment:\n%s\n", yytext);
                            comment();
                           }
                           */
  /* TODO: ask TA, how can I check an unterminated comment???? */
  // "/*"                       { FILTER( COMMENT_START); }
  // "*/"                       { FILTER( COMMENT_END); }
"//".*                     { /* consume comment */ }

  /* Keywords */
"if"                       { FILTER( IF); }  
"else"                     { FILTER( ELSE); }       
"while"                    { FILTER( WHILE); }
"do"                       { FILTER( DO); }
"for"                      { FILTER( FOR); }
"return"                   { FILTER( RETURN); }
"extern"                   { FILTER( EXTERN); }
"export"                   { FILTER( EXPORT); }

"("                        { FILTER( BRACKET_L); }
")"                        { FILTER( BRACKET_R); }
","                        { FILTER( COMMA); }
";"                        { FILTER( SEMICOLON); }
  
"-"                        { FILTER( MINUS); }
"+"                        { FILTER( PLUS);  }
"*"                        { FILTER( STAR);  } 
"/"                        { FILTER( SLASH);  } 
"%"                        { FILTER( PERCENT);  } 
 
"<="                       { FILTER( LE);    }
"<"                        { FILTER( LT);    } 
">="                       { FILTER( GE);    }
">"                        { FILTER( GT);    }
"=="                       { FILTER( EQ);    }
"!="                       { FILTER( NE);    }
"&&"                       { FILTER( AND);    }
"||"                       { FILTER( OR);    }

"="                        { FILTER( LET);    }

  /* Negation */
"!"                        { FILTER( NEG);    }

"true"                     { FILTER( TRUEVAL); }
"false"                    { FILTER( FALSEVAL); }

  /* civic types */
"int"                      { FILTER( INTTYPE); }
"float"                    { FILTER( FLOATTYPE); }
"bool"                     { FILTER( BOOLTYPE); }
"void"                     { FILTER( VOIDTYPE); }

  /* ID in parser now contains the value that is in yytext (read from input)  */
[A-Za-z][A-Za-z0-9_]*      { yylval.id = STRcpy(yytext);
                             FILTER( ID);
                           }

{INTEGER}                  { yylval.cint=atoi(yytext);
                             FILTER( NUM);
                           }
{FLOAT}                    { yylval.cflt=atoi(yytext);
                             FILTER( FLOAT);
                           }

  /* Whitespace and other characters at the bottom, you want to read them if there is no other token */
\n.*                       { 
                             yycolumn = 1;
                             global.line += 1;
                             global.col = 0;
                             yyless(1);
                           }
[ \t]                      { global.col += yyleng;
                           } 
%%

static inline void token_action() {
    yylloc.first_line = yylloc.last_line = yylineno;
    yylloc.first_column = yycolumn;
    yylloc.last_column = yycolumn + yyleng - 1;
    yycolumn += yyleng;
}

// static void comment(void)
// {
//     int c;

//     while ((c = input()) != 0)
//         if (c == '*')
//         {
//             while ((c = input()) == '*')
//                 ;

//             if (c == '/')
//                 return;

//             if (c == 0)
//                 break;
//         }
//     yyerror("unterminated comment");
// }

